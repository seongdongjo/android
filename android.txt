package com.example.kotlin


fun main() { //메인함수
    println("Hello world")
    test()
    val result = test2(1,3)
    println(result)
}
//코틀린에서는 함수는 무조건 리턴이 있다.
//fun test() : Unit { //이렇게 Unit이 숨겨져있다고 보면된다. 여기서 Unit은 void 같은거다.
//    println()
//}
//2. 함수
fun test() {
    println("test")
}

fun test2(a: Int, b: Int) : Int {
    println(a+b)
    return a+b
}

//오버로딩
fun test2(a: Int) : Int {
    val b = 3
    println(a+b)
    return a+b
}

//근데, 코틀린에서는 오버로딩이 필요없다 -> default값을 주면된다. b: Int = 3
//호출할 때는 test(a:1)
//fun test2(a: Int, b: Int = 3) : Int {
//    println(a+b)
//    return a+b
//}

====================================================
package com.example.kotlin

fun main() { //메인함수
    //파라미터 순서가 달라도 이렇게 명시적으로 하면 문제가 없다.
    test2(id="상아님", name="채상아", nickname="상아")
    println(times(1,3))
    println(sametimes(1,3))
}

fun test2(name: String, nickname: String, id: String) = println(name+nickname+id)

//단일표현식으로 함수 표현
fun times(a: Int, b: Int) = a*b

//위와 같다
fun sametimes(a: Int, b: Int) : Int {
    return a*b;
}

=================================================
package com.example.kotlin

fun main() {
    //3. 변수
    // val = value(값)
    // var = variable(변경가능한)

    val a : Int = 3
    var b : Int = 10
    //a = 20 에러가난다
    b = 20

    //코틀린은 타입추론이 있어서 뒤에 타입이 없어도 된다.
    val name = "채상아"
    
}
=================================================
package com.example.kotlin

fun main() {
    val user = User("채상아", 10)
    //user.name 접근불가능 private이라서
    println(user.age)
}

class User(private val name: String, var age: Int = 100) {

}

=================================================
package com.example.kotlin

fun main() {
    Kid("아이", 3, "male")
}

//open을 이용해서 상속을 허용해야한다.
open class User(open val name: String, open var age: Int = 100)

//기본생성자는 생략
class Kid(override val name: String, override var age: Int) : User(name,age) {
    var gender: String =  "female"

    //가장먼저 호출
    init {
        println("초기화 중입니다.")
    }

    constructor(name: String, age: Int, gender: String) : this(name,age) {
        this.gender = gender
        println("부 생성자 호출")
    }
}
=================================================
//조건식
package com.example.kotlin

fun main() {
    max(10,3)
}

fun max(a: Int, b: Int) {
    if(a>b) {
        println(a)
    } else {
        println(b)
    }
}

//자바와 다르게 변수로 받을 수 있다.
fun max1(a: Int, b: Int) {
    val result = if(a>b) {
        println(a)
    } else {
        println(b)
    }
    println(result) //출력: kotlin.Unit -> void이기 때문에 print는
}

fun max2(a: Int, b: Int) {
    val result = if(a>b) {
        a
    } else {
        b
    }
    println(result) //출력: 10
}

=================================================
package com.example.kotlin

fun main() {
    max(10,3)
    isHoliday2("금")
}

//코틀린은 삼항연산자가 없다.
//코틀린은 조건문이 아니라 조건식이라서 변수로 받을 수 있다.
fun max(a: Int, b: Int) {
    val result = if(a>b) a else b //중괄호 생략가능
    println(result)
}

//월 화 수 목 금 토 일
fun isHoliday(dayOfWeek: String) {
    when(dayOfWeek) {
        "월" -> false
        "화" -> false
        "수" -> false
        "목" -> true
        "금" -> true
        "토" -> true
        "일" -> true
    }
}

//월 화 수 목 금 토 일
fun isHoliday1(dayOfWeek: String) {
    when(dayOfWeek) {
        //같은 값은 콤마로 생략가능
        "월",
        "화",
        "수" -> false
        "목",
        "금",
        "토",
        "일" -> true
    }
}

//월 화 수 목 금 토 일
fun isHoliday2(dayOfWeek: String) {
    val result = when(dayOfWeek) {
        //case에서 default를 썻다면 여기는 else가 default다
        "월",
        "화",
        "수" -> true
        else -> false
    }
    println(result) //출력: false
}

fun isHoliday3(dayOfWeek: String) {
    when(val day = dayOfWeek) { //이렇게 받아서 쓸 수도 있다.
        "토",
        "일" -> if(day == "토") "좋아" else "너무좋아"
        else -> "안좋아"
    }
}

fun isHoliday(dayOfWeek: Any) { //어떤걸 받든 상관없다 -> Any
    when(dayOfWeek) {
        "토",
        "일" -> if(dayOfWeek == "토") "좋아" else "너무좋아"
        in 2..4 -> {}  //파라미터가 정수이면 이걸쓰면된다.
        in listOf("월", "화") -> {}  //파라미터가 "월", "화" 이면
        else -> "안좋아"
    }
}

=====================================================
//반복문
package com.example.kotlin

fun main() {
    // for(int i = 1; i<11; i++) {
    //
    //}
    for(i in 1..10) {  //이거와 같은게 IntRange(1,10)
        print(i)
        print(".")
    }
    
    //위와 같은 의미이다.
    for(i in IntRange(1,10)) {
        print(i)
        print(".")
    }
}
====================================================
package com.example.kotlin

fun main() {
    for(i in 1 until 10) { //until은 끝에 숫자를 포함하지 않는다.
        print(i)
        print(".")
    }

    for(i in 1..10 step(2)) {//2씩 증가
        print(i)
        print(".")
    }

    for(i in 10 downTo 1) { //10부터 작아지게 만들겠다.
        print(i)
        print(".")
    } // 10.9.8.7....

    for(i in 10 downTo 1 step(2)) {
        //출력: 10.8.6.4....
    }

    var c = 1
    while(c<11)  {
        print(c)
        c++
    }
}
==================================================
package com.example.kotlin

fun main() {
    //컬렉션에는 mutable, immutable이 있는데 변경할려면 mutable로 선언해야한다.

    val list = mutableListOf(1,2,3,4,5) //변경가능한 리스트
    list.add(6)
    list.addAll(listOf(7,8,9)) //리스트안에 리스트

    val list1 = listOf(1,2,3,4)
    //list1.add 에러가 난다. 변경이 불가하다. (immutable)
    list1.get(0)
    list1[0]
    println(list1.map { it * 10}.joinToString("/")) //10을 곱해서 리스트 다시 만들어
    //출력: 10/20/30/40

    //자바와다르게 리스트에 다양한 타입을 넣을 수 있다.
    val diverseList = listOf(1, "안녕", 1.78, true)

    println(list.joinToString(",")) //확인하는 법

    val map = mapOf((1 to "안녕"), (2 to "hello")) //여기서는 put이 불가능하다(immuta
    val map1 = mutableMapOf((1 to "안녕"), (2 to "hello"))
    map1.put(3, "응") //map1은 mutable이라서 변경가능하다.
    map1[3] = "응"
    map1[100] = "호이"

}
====================================================
package com.example.kotlin

fun main() {
    var name: String = "상아"
    //name = null 에러가난다 String에는 이미 null이 들어갈수없다는 의미가 내포되있기 때문이다.

    var number: Int = 10
    //number = null

    //이렇게 컴파일단계에서 null여부를 구분지을수있기때문에 좋다.
    //해당타입이 null이 들어갈수있다는 의미다.
    var nickName: String? = null
    var secondNumber: Int? = null

    //일반적인 예시
    var result = if(nickName == null) {
        "값이없음"
    } else {
        nickName
    }
    
    //코틀린에서 쓰는 예
    val result = nickName?: "값이 없음" //값이 null이면 "값이 없음"을 반환해라 의미이다
    println(result)

    //또 다른 예시
    //동작하다가 변수에 null이 들어갈수있으니까 이렇게 안전하게 해줘야한다.
    val size = nickName?.length;  //nickName이 null이면 null로 반환해준다. 에러없이
    val size1 = nickName!!.length // null이 동작중에 안들어갈거라는 확신이 있을 때
}

======================================================
VTS 제안서 작업
선원센터 푸시알림 심사 및 카드등록
선원센터 푸시알림 APNs, FCM key,id 생성
선원센터 푸시알림 서버단 전송 구현

package com.example.kotlin

fun main() {
    check("안녕") //출력: 문자열
}

fun check(a: Any) : String {
    return if(a is String) { //타입체킹
        "문자열"
    }else if(a is Int) {
        "숫자"
    } else {
        "모름"
    }
}

fun check(a:Any) : String {
    return when (a) {
        is String -> {
            "문자열"
        }
        is Int -> {
            "숫자"
        }else -> {
            "몰라요"
        }
    }
}

=====================================================
package com.example.kotlin

fun main() {
   cast("안녕") //안녕
   cast(10)    //Exception에러가난다. -> String으로 변환이 안되기때문에
   println(smartcast("안녕")) // 2
   println(smartcast(10)) // 9
   println(smartcast(true)) // -1
}

fun cast(a : Any) {
   val result = a as String
   println(result)
}

//Exception 에러가 안나게 하기 위해서 아래와 같이 작성해야함
fun cast(a: Any) {
   val result = a as? String  // 물음표를 붙임으로써 캐스팅이 안되도 에러 발생안하고 null를 반환한다.
   val result = (a as? String) ?: "실패"  //null이 나오면 실패
   println(result)
}

fun smartcast(a: Any) {
   return if(a is String) { //String 인걸체킹 했기때문에 a.length 가능
      a.length
   } else if(a is Int) {
      a.dec()  //숫자-1
   } else {
      -1
   }
}
=====================================================


























































