package com.example.kotlin


fun main() { //메인함수
    println("Hello world")
    test()
    val result = test2(1,3)
    println(result)
}
//코틀린에서는 함수는 무조건 리턴이 있다.
//fun test() : Unit { //이렇게 Unit이 숨겨져있다고 보면된다. 여기서 Unit은 void 같은거다.
//    println()
//}
//2. 함수
fun test() {
    println("test")
}

fun test2(a: Int, b: Int) : Int {
    println(a+b)
    return a+b
}

//오버로딩
fun test2(a: Int) : Int {
    val b = 3
    println(a+b)
    return a+b
}

//근데, 코틀린에서는 오버로딩이 필요없다 -> default값을 주면된다. b: Int = 3
//호출할 때는 test(a:1)
//fun test2(a: Int, b: Int = 3) : Int {
//    println(a+b)
//    return a+b
//}

====================================================
package com.example.kotlin

fun main() { //메인함수
    //파라미터 순서가 달라도 이렇게 명시적으로 하면 문제가 없다.
    test2(id="상아님", name="채상아", nickname="상아")
    println(times(1,3))
    println(sametimes(1,3))
}

fun test2(name: String, nickname: String, id: String) = println(name+nickname+id)

//단일표현식으로 함수 표현
fun times(a: Int, b: Int) = a*b

//위와 같다
fun sametimes(a: Int, b: Int) : Int {
    return a*b;
}

=================================================
package com.example.kotlin

fun main() {
    //3. 변수
    // val = value(값)
    // var = variable(변경가능한)

    val a : Int = 3
    var b : Int = 10
    //a = 20 에러가난다
    b = 20

    //코틀린은 타입추론이 있어서 뒤에 타입이 없어도 된다.
    val name = "채상아"
    
}
=================================================
package com.example.kotlin

fun main() {
    val user = User("채상아", 10)
    //user.name 접근불가능 private이라서
    println(user.age)
}

class User(private val name: String, var age: Int = 100) {

}

=================================================
package com.example.kotlin

fun main() {
    Kid("아이", 3, "male")
}

//open을 이용해서 상속을 허용해야한다.
open class User(open val name: String, open var age: Int = 100)

//기본생성자는 생략
class Kid(override val name: String, override var age: Int) : User(name,age) {
    var gender: String =  "female"

    //가장먼저 호출
    init {
        println("초기화 중입니다.")
    }

    constructor(name: String, age: Int, gender: String) : this(name,age) {
        this.gender = gender
        println("부 생성자 호출")
    }
}
=================================================
//조건식
package com.example.kotlin

fun main() {
    max(10,3)
}

fun max(a: Int, b: Int) {
    if(a>b) {
        println(a)
    } else {
        println(b)
    }
}

//자바와 다르게 변수로 받을 수 있다.
fun max1(a: Int, b: Int) {
    val result = if(a>b) {
        println(a)
    } else {
        println(b)
    }
    println(result) //출력: kotlin.Unit -> void이기 때문에 print는
}

fun max2(a: Int, b: Int) {
    val result = if(a>b) {
        a
    } else {
        b
    }
    println(result) //출력: 10
}

=================================================
package com.example.kotlin

fun main() {
    max(10,3)
    isHoliday2("금")
}

//코틀린은 삼항연산자가 없다.
//코틀린은 조건문이 아니라 조건식이라서 변수로 받을 수 있다.
fun max(a: Int, b: Int) {
    val result = if(a>b) a else b //중괄호 생략가능
    println(result)
}

//월 화 수 목 금 토 일
fun isHoliday(dayOfWeek: String) {
    when(dayOfWeek) {
        "월" -> false
        "화" -> false
        "수" -> false
        "목" -> true
        "금" -> true
        "토" -> true
        "일" -> true
    }
}

//월 화 수 목 금 토 일
fun isHoliday1(dayOfWeek: String) {
    when(dayOfWeek) {
        //같은 값은 콤마로 생략가능
        "월",
        "화",
        "수" -> false
        "목",
        "금",
        "토",
        "일" -> true
    }
}

//월 화 수 목 금 토 일
fun isHoliday2(dayOfWeek: String) {
    val result = when(dayOfWeek) {
        //case에서 default를 썻다면 여기는 else가 default다
        "월",
        "화",
        "수" -> true
        else -> false
    }
    println(result) //출력: false
}

fun isHoliday3(dayOfWeek: String) {
    when(val day = dayOfWeek) { //이렇게 받아서 쓸 수도 있다.
        "토",
        "일" -> if(day == "토") "좋아" else "너무좋아"
        else -> "안좋아"
    }
}

fun isHoliday(dayOfWeek: Any) { //어떤걸 받든 상관없다 -> Any
    when(dayOfWeek) {
        "토",
        "일" -> if(dayOfWeek == "토") "좋아" else "너무좋아"
        in 2..4 -> {}  //파라미터가 정수이면 이걸쓰면된다.
        in listOf("월", "화") -> {}  //파라미터가 "월", "화" 이면
        else -> "안좋아"
    }
}

=====================================================
//반복문
package com.example.kotlin

fun main() {
    // for(int i = 1; i<11; i++) {
    //
    //}
    for(i in 1..10) {  //이거와 같은게 IntRange(1,10)
        print(i)
        print(".")
    }
    
    //위와 같은 의미이다.
    for(i in IntRange(1,10)) {
        print(i)
        print(".")
    }
}
====================================================
package com.example.kotlin

fun main() {
    for(i in 1 until 10) { //until은 끝에 숫자를 포함하지 않는다.
        print(i)
        print(".")
    }

    for(i in 1..10 step(2)) {//2씩 증가
        print(i)
        print(".")
    }

    for(i in 10 downTo 1) { //10부터 작아지게 만들겠다.
        print(i)
        print(".")
    } // 10.9.8.7....

    for(i in 10 downTo 1 step(2)) {
        //출력: 10.8.6.4....
    }

    var c = 1
    while(c<11)  {
        print(c)
        c++
    }
}
==================================================
package com.example.kotlin

fun main() {
    //컬렉션에는 mutable, immutable이 있는데 변경할려면 mutable로 선언해야한다.

    val list = mutableListOf(1,2,3,4,5) //변경가능한 리스트
    list.add(6)
    list.addAll(listOf(7,8,9)) //리스트안에 리스트

    val list1 = listOf(1,2,3,4)
    //list1.add 에러가 난다. 변경이 불가하다. (immutable)
    list1.get(0)
    list1[0]
    println(list1.map { it * 10}.joinToString("/")) //10을 곱해서 리스트 다시 만들어
    //출력: 10/20/30/40

    //자바와다르게 리스트에 다양한 타입을 넣을 수 있다.
    val diverseList = listOf(1, "안녕", 1.78, true)

    println(list.joinToString(",")) //확인하는 법

    val map = mapOf((1 to "안녕"), (2 to "hello")) //여기서는 put이 불가능하다(immuta
    val map1 = mutableMapOf((1 to "안녕"), (2 to "hello"))
    map1.put(3, "응") //map1은 mutable이라서 변경가능하다.
    map1[3] = "응"
    map1[100] = "호이"

}
====================================================
package com.example.kotlin

fun main() {
    var name: String = "상아"
    //name = null 에러가난다 String에는 이미 null이 들어갈수없다는 의미가 내포되있기 때문이다.

    var number: Int = 10
    //number = null

    //이렇게 컴파일단계에서 null여부를 구분지을수있기때문에 좋다.
    //해당타입이 null이 들어갈수있다는 의미다.
    var nickName: String? = null
    var secondNumber: Int? = null

    //일반적인 예시
    var result = if(nickName == null) {
        "값이없음"
    } else {
        nickName
    }
    
    //코틀린에서 쓰는 예
    val result = nickName?: "값이 없음" //값이 null이면 "값이 없음"을 반환해라 의미이다
    println(result)

    //또 다른 예시
    //동작하다가 변수에 null이 들어갈수있으니까 이렇게 안전하게 해줘야한다.
    val size = nickName?.length;  //nickName이 null이면 null로 반환해준다. 에러없이
    val size1 = nickName!!.length // null이 동작중에 안들어갈거라는 확신이 있을 때
}

======================================================
VTS 제안서 작업
선원센터 푸시알림 심사 및 카드등록
선원센터 푸시알림 APNs, FCM key,id 생성
선원센터 푸시알림 서버단 전송 구현

package com.example.kotlin

fun main() {
    check("안녕") //출력: 문자열
}

fun check(a: Any) : String {
    return if(a is String) { //타입체킹
        "문자열"
    }else if(a is Int) {
        "숫자"
    } else {
        "모름"
    }
}

fun check(a:Any) : String {
    return when (a) {
        is String -> {
            "문자열"
        }
        is Int -> {
            "숫자"
        }else -> {
            "몰라요"
        }
    }
}

=====================================================
package com.example.kotlin

fun main() {
   cast("안녕") //안녕
   cast(10)    //Exception에러가난다. -> String으로 변환이 안되기때문에
   println(smartcast("안녕")) // 2
   println(smartcast(10)) // 9
   println(smartcast(true)) // -1
}

fun cast(a : Any) {
   val result = a as String
   println(result)
}

//Exception 에러가 안나게 하기 위해서 아래와 같이 작성해야함
fun cast(a: Any) {
   val result = a as? String  // 물음표를 붙임으로써 캐스팅이 안되도 에러 발생안하고 null를 반환한다.
   val result = (a as? String) ?: "실패"  //null이 나오면 실패
   println(result)
}

fun smartcast(a: Any) {
   return if(a is String) { //String 인걸체킹 했기때문에 a.length 가능
      a.length
   } else if(a is Int) {
      a.dec()  //숫자-1
   } else {
      -1
   }
}
=====================================================
fun main() {
    //변수
    val box1 = "test box1";
    println(box1) //출력

    box1 = "new box1" //에러가 난다.(val로 선언했기떄문에) -> var써야한다.
    println(box1) 
    
    
    println("123" + 4) //1234 -> 텍스트로 취급해서 4도 텍스트로 취급된다.
    println(123+4) //127
}
======================================================
fun main() {
    val test1 = "1234"
    val test2 = 1234
    
    //타입출력
    println(test1::class.java.simpleName)  //String
    println(test2::class.java.simpleName)  //int
    
    val test3 = 1234.1234
    println(test3::class.java.simpleName) //double
    
    //이렇게도 가능하다.
    val test4 : Int = 1234 

    //타입을 잘못넣었을때 에러가난다.
    val test5 : Int =  "1234"
    
    val test7 : Long = 1234123412341234
    
    val test8 : Float = 1234.1234f
    
    //데이터 타입 변경하고 싶을 때
    val test9 : Int = 1234
    val test10 : test9.toString()
    println(test10::class.java.simpleName) //String
    
    
    //또 다른 데이터타입 변경방법
    val test11 : String = "1234"
    val test12 = Integer.parseInt(test11)  //Integer로 변경

    
    //null
    val test13 = ""  //빈문자열
    val test14 = null //아예 없다.
    
    val test15 : String = null //에러가난다.
    val test16 : String? = null //에러가안난다
    val test16 : String? = "abc"
}

=================================================================
val score = 100
when(score) {
    100->{
        println("100")
    }
    90-> {
        println("90")
    }
    80-> {
        println("80")
    }
    else -> {
        print("no")
    }
}
===================================================================
fun main() {
    //리스트 만드는법
    val testList1 = ArrayList<String>()
    testList1.add("a")
    testList1.add("b")
    testList1.add("c")
    println(testList1) //[a,b,c]
    println(testList1[0]) //a
    
    //또 다른 리스트만드는법
    val testList2 = listOf("a","b","c")
    println(testList2) //[a,b,c]
    
    //또 다른 방법
    val testList3 = mutableListOf<String>("a","b","c")
    val testList3 = mutableListOf("a","b","c")   //<String> 생략가능
    println(testList3)
}


===========================================================
//필터링
fun main() {
    val testList4=listOf("student1","student2","student3","student4","teacher1","student5")
    testList4.filter{it.startsWith("s")} //{student1, student2, student3, student4, studnet5}
    
    val testList5=listOf("student1","student2","student3","student4","teacher1","student5", null)
    testList5.filter{it.startsWith("s")} //null이 있을 때는 필터링을 할 수가 없다.
    testList5.filterNotNull().filter {it.startsWith("s")}
    
    
    var test1 : String = "a"
    var test2 : String = "b"
    test1 = test2 //b
    
    var test3 : String = "c"
    var test4 : String? = "d"
    test3 = test4  //null이 아닌 값을 null일수도 있는 값을 넣을수가없다.
    test3 = test4!!  //null이 아니다 라고 표시하면 됨
}

=============================================================
//반복문
val testList6 = listOf("a","b","c","d","e","f")
for(i in testList6) {
    println(i)
}

for(i in 1..3) {
    println("i의 값은: $i") //두 개 같은 의미이다.
    println("i의 값은:" +i )
}


for(i in 1..3) {
    for(j in 1..3) {
        println("i is $i j is $j")  // i is 1 j is 1 , 1 2, 1 3, ...
    }
}


=================================================================
//List

fun main() {
    val testList1 = listOf("a","b","c") //근데 이방식은 값이 추가가 안된다.
    println(testList1)
    
    //값 추가가능
    val testList2 = mutableListOf("a","b","c")
    testList2.add("d")
    testList2.remove("a") //[b,c,d]
    
}

//Map

fun main() {
    //Map을 안쓰면 List에서 일일이 인덱스를 받고 그 인덱스로 검색을해서 value로 가져와야한다.
    val testMap1 = mutableMapOf<Int,String>()
    testMap1.put(2,"유리")
    testMap1.put(10,"철수")
    testMap1.put(15,"짱구")
    testMap1.put(22,"훈이")

    testMap1[10] //철수 
}

//Set(중복허용x)

fun main() {
    val testSet1 = mutableSetOf("a","b","c")
    testSet1.add("d"); // [a,b,c,d]
    testSet1.remove("d")
}

=============================================================
//While

fun main() {
    var count = 0
    
    while(count < 100) {
        count++ //99까지만
    }
    
    val testMap2 = mutableMapOf<Int, String>()
    testMap2[5] = "유리1"
    testMap2[15] = "유리2" //이렇게 key, value를 넣어도된다.(put안쓰고)
    //{5=유리1, 15=유리2}
}


// Iterator
fun main() {
    val testList2 = mutableListOf("a","b","c")   
    val testIterator = testList2.listIterator()    //  |a|b|c|
    println(testIterator.next()) //a
    println(testIterator.next()) //b
    println(testIterator.hasNext()) //true(다음에 값이 있다)
    println(testIterator.next()) //c
    println(testIterator.hasNext()) //false
    println(testIterator.previous()) //c (이전값으로)
    
    while(testIterator.hasNext()) {
        println(testIterator.next())
    }
}

==========================================================
//50점 이상 출력
fun main() {
    val student = mutableMapOf<Int, String>()
    student[99] = "민지" //key는 점수
    student[20] = "철수"
    student[35] = "민수"
    student[48] = "가영"
    student[100] = "하영"
    
    val testList=ArrayList<String>()
    
    for(i in student) {
        print(i.key) //99, 20, ..
        if(i.key >= 50) {
            println(i) //99=민지, 100=하영, ..
            println(i.value)
            testList.add(i.value) //리스트에 담아서
        }
    }
}
=========================================================
//함수

fun main() {
    abc() //30
    sum(10,20) //30
    println(sum2(10,20)) //30 
    bobMaking(5)
}

fun sum(a: Int, b: Int) {
    println(a+b)
}

fun sum2(a: Int, b: Int) : Int {
    val result = a+b
    return result
}

fun bobMaking(time: Int) {
    println("$time 시간 후에 밥이 완료됩니다")
}

fun abc() {
    val a = 10
    val b = 20
    val c = a+b
    println(c)
}

========================================================
//논리연산
fun main() {
    val a = "남자"
    val b = 20
    
    //And
    if(a=="남자" && b>=20) {
        
    } else {
    
    }
    
    //OR
    val c = "남자"
    val d = 30
    if(c=="남자" || d >= 30) {
        
    }
}

============================================================
fun main() {
    val student = mutableMapOf<Int, String>()
    student[99] = "민지" //key는 점수
    student[20] = "철수"
    student[35] = "민수"
    student[48] = "가영"
    student[100] = "하영"
    
    for(i in student) {
        if(i.key >= 50 && i.value.length > 2) {
        
        }
    }
}
==============================================================
//문자열 가공
fun main() {
    val testString = "동해물과 백두산이 마르고 닳도록"
    val newTestString = testString.split(" ")
    val replaceValue = testString.replace("백두산", "한라산") //백두산을 한라산으로
    println(newTestString) // [동해물과, 백두산이, 마르고, 닳도록]
    println(newTestString[0]) //동해물과
    
    println(testString[0]) //동 -> 이렇게 하나씩 가져오면 번거롭다
    
    println(testString.substring(0,2)) //동해
    println(0,testString.length-1)  //~~닳도
    
}
===============================================================
seongdong@naver.com -> split("@")[1]  -> naver.com -> split("@")[1].split(".") -> [naver, com]
-> split("@")[1].split(".")[0]  -> naver
===============================================================
//엘비스 연산자
fun main() {
    var testStr1 : String = ""
    println(testStr1) //공백출력
    
    var testStr2 = null
    println(testStr2) //null
    
    var testStr3 : String = "abcd"
    var testStr4 : String  = null(에러가난다 String에는 null안된다) "null"은 들어간다(문자열자체라서)
    var testStr4 : String? = null
}

//예시
fun main() {
    println(findStringLength1("asdf")) //null을 넣으면 에러가난다.
}

fun findStringLength1(str:String) : Int {
    return str.length
}

fun findStringLength2(str:String?) : Int? {  //null일수도있으니
    return str?.length //null 일수도 있으니


//이렇게 하는게 편하지
fun findStringLength3(str: String?) : Int {
    var resultCount = 0
    if(str != null) {
        resultCount = str.length
    }
    return resultCount
}

//이것도 귀찮으니 엘비스 연산자를 쓰자
fun findStringLength4(str : String?) : Int {
    return str?.lentgh ? : 0  //null이면 0을 리턴 아니면 문자열길이를 리턴
}
 
}

==============================================================
//Any
fun main() {
    var str1 : String = "abc"
    str1 = 123 //에러난다
    
    var str2 : Any = "abc"
    str2 = 123 //int타입이여도 잘된다.
    
    //타입확인
    // is는 맞나 확인하는 용도
    // as는 type casting이다.
    
    var str3 : Any = "abc"
    if(str3 is String) {
        println("this is string")
    }
}
==============================================
fun main() {
    var str4 : Any = "abc"
    when(str4) {
        is Int -> {println("this is int")}
        is String ->  {println("this is string")}
        else -> {
            println("this is else")
        }
    }
}
=================================================
fun main() {
    var str5 : String = "abc"
    var str6 : String = str5 as String  //문자열로 집어넣어라
    
    var str7 : Int = 1
    var str8 : String = str7 as String //에러가난다.타입문제
    
    //그래서
    var str9 : String? = 1 as? String  //타입변경이 안되면 null, ?가 없으면 에러가 난다.
    println(str9) //null
}

================================================
// List 가공하기
fun main() {
    val testList1 = mutableListOf<Int>()
    testList1.add(1)
    testList1.add(2)
    testList1.add(3)
    testList1.add(4)
    testList1.add(10)
    testList1.add(10)
    testList1.add(11)
    testList1.add(11)
    
    println(testList1.distinct()) // 중복제거 [1,2,3,4,10,11]
    println(testList1.maxOrNull()) //큰값 11
    println(testList1.minOrNull()) // 1
    println(testList1.average()) // 6.5
}

=====================================================
fun main() {
    val testList2 = listOf("john", "jay", "minsu", "minji", "bokchi")
    
    val result1 = testList2.filter {
        it.startsWith("j")
    }
    println(result1)  // [john, jay]
    
    
    //짝수만
    val testList3 = listOf(1,2,3,4,5)
    val result2 = testList3.filter {
        it % 2 == 0
    }
    println(result2) // [2,4]
    
    
    //해당되는 애들을 그룹으로 묶고싶다
    val testList4 = listOf("a", "aa", "aaa", "aaaa")
    val result3 = testList4.groupBy {
        it.length > 2
    }
    println(result3) // {false=[a,aa], true=[aaa,aaaa]}
    println(result3[true]) //true값만  ->  [aaa,aaaa]
}

======================================================
//function -> 기능
//class -> 설계 + 기능

fun main() {
    println(Test().a) //abc
    println(Test2("abcd").b) //abcd
    println(Test3().test3Fun())
    
    val myinfo = Myinfo()
    println(myinfo.getMyage()) //20 
    
    val dog = Dog("파트라슈",20)
    dog.getMyDogInfo()  //파트라슈 : 20
}

class MyInfo() {
    fun getMyage() : Int {
        return 20
    }
    fun getMyName() : String {
        return "MyName is"
    }
    fun getMyLocation() : String {
        return "Sodeul"
    }
}

class Test3() {
    fun test3Fun() {
        println("test3Fun 출력")
    }
}

class Test2(str : String) {
    val b = str
}

class Test {
    val a = "abc"
}

class Dog(name: String, age: Int) {
    val dogName = name
    val dogAge = age
    fun getMyDogInfo() : String {
        return "$dogName:$dogAge"
    }
}


========================================================
fun main() {
    initTest()  //시작
    initTest().testInitFun() //시작
                             //testInitFun

    InitialValue("박보검",20)  
    InitialValue("박보검") //만약에 "박보검" 만 인자로 줘도 에러가 안나게끔할려면 함수에서 디폴트 값을 주면된다.  
}

class InitialValue(name:String, age:Int=20) {
    init {
        println(name)
        println(age)
    }
}

class initTest() {
    
    init {
        println("시작")
    }
    
    fun testInitFun() {
        println("testInitFun")
    }
}

==========================================================
//오버로딩
//같은 이름의 메서드를 여러개 가지면서, 매개변수의 유형과 개수가 다르도록

fun main() {
    val c = Calculator()
    c.sumNumber(1,2)
    c.sumNumber(1,2,3)
    c.sumNumber("나는","콜백")
}

class Calculator() {
    fun sumNumber(a:Int,b:Int) {
        println(a+b)   
    }
    fun sumNumber(a:Int,b:Int,c:Int) {
        println(a+b+c)
    }
    fun sumNumber(a:String,b:String) {
        println(a+b)
    }
}
============================================================
//상속을 사용하지 않을 때
fun main() {
    Job1()
    Job2()
}

class Job1() {
    init {
        println("일을 합니다")
        println("코딩을 합니다")
    }
}
class Job2() {
    init {
        println("일을 합니다")
        println("디자인을 합니다")
    }
}


==========================================================
//상속을 사용할 때
fun main() {
    Job3()  //일을합니다
            //마케팅을 합니다
}

open class AllJobs() {
    init {
        println("일을 합니다.")
    }
}

class Job3() : AllJobs() {
    init {
        println("마케팅을 합니다.")
    }
}

=============================================================
//상속과 오버라이딩
fun main() {
    Child()    //이것은 부모입니다.
               //이것은 자식입니다.
}

open class Parents() {
    init {
        println("이 것은 부모입니다.")
    }
}

class Child() : Parents() {
    init {
        println("이 것은 자식입니다")
    }
}
==============================================================
//상속과 오버라이딩
fun main() {
    Parents().doing() //자식을 돌봅니다.
    
    Child().disease() //부모꺼를 사용가능하다.
    Child().doing() //겁이 많습니다.
}

open class Parents() {
    open fun doing() {
        println("자식을 돌봅니다")
    }
    fun disease() {
        println("비염이 있습니다.")
    }
}

class Child() : Parents() {
    override fun doing() {
        println("겁이 많습니다")
    }
}
===============================================================
//추상클래스 
// class -> 붕어빵 틀
// abstract class ->  기존에는 비어있고 꽉 채워서 붕어빵을 만들어야하는 틀

//기존 방식
fun main() {
    Bike().wheel()
    Bike().engine() //부모꺼 사용
}

open class Car {
    open fun wheel() {
        println("굴러갑니다")
    }
    open fun engine() {
        println("시동이 켜졌습니다.")
    }
}

class Bike() : Car() {
    override fun wheel() {
        println("자전거가 굴러갑니다")
    }
}

========================================================
//추상클래스 -> 공통적인 기능을 사용할 때
fun main() {
    BMW().wheel()
    BMW().engine()
}


//빈 붕어빵 틀
abstract class Car {
    abstract fun wheel()
    abstract fun wheel()
}

//위의 빈 붕어빵 틀을 꽉채워서 사용
class BMW() : Car() {
    override fun wheel() {
        println("비엠따블류")
    }
    override fun engine() {
        println("BMW 시동 걸립니다")
    }
}
======================================================
//인터페이스 -> 추상 클래스 처럼 꼭 채워넣어야하는 붕어빵 틀인데 작은 틀이라서 다른틀에 여러개 넣을 수 있다.

fun main() {
    BMW().wheel()
    BMW().engine()
}

interface Car {
    fun wheel()
    fun engine()
}

class BWM() : Car {
    override fun wheel() {
        println("wheel 돌어감")
    }
    override fun engine() {
        println("BMW 엔진 돌아감")
    }
}

=============================================================
//그럼 어떨 때 쓸까
fun main() {
    
}

abstract class Car {  //큰틀개념 찍어내는
    abstract fun wheel()
    abstract fun engine()
}

interface CarAutoDriving {
    fun autoDriving()
}

interface CarAutoParking {
    fun autoParking()
}

class BMW() : Car(), CarAutoDriving, CarAutoParking {
    override fun wheel() {
        println("BMW 굴러감")
    }
    override fun engine() {
        println("BMW 엔진시동")
    }
    override fun autoDriving() {
        println("자율주행")
    }
    override fun autoParking() {
        println("자율주차")
    }
}

class Benz() : Car() {
    override fun wheel() {
        println("Benz 굴러감")
    }
    override fun engine() {
        println("Benz 엔진시동")
    }
    fun autoParking() {
        println("자율주차")
    }
}

=========================================================
//Data Class
//데이터를 넣어놓는 클래스
fun main() {
    val justDog = JustDog("파트라슈",21)
    println(justDog.name) //잘나온다 -> 그럼, 그냥 클래스에 데이터 넣으면 안됨??
    println(justDog.toString()) //객체주소가 나온다.(이게 데이터 클래스랑 차이다)
    
    val dataDog = DataDog("파트라슈 친구",15)
    println(dataDog.toString()) //DataDog(name=파트라슈 친구, age=15) //데이터 클래스는 이렇게나온다

    val dataDog2 = dataDog.copy(name="파트라슈 여자친구")
    println(dataDog2.toString())  //DataDog(name=파트라슈 여자친구, age=15)
}

//그냥 클래스로 데이터 넣을때 예시
class JustDog(var name : String, var age: Int)

//데이터 클래스에 넣을 때 예시
data class DataDog(var name: String, var age: Int)

//똑같은데 언제 쓰임? -> 서버에서 데이터를 받아온것을 넣을때

==========================================================
//중첩클래스

fun main() {
    val test1 = Test1().TestNestedClass()
    test1.testFun1()
    
    val test2 = Test2().Test2InnerClass()
    test2.testFun2()
}

class Test1 {
    val tempText1="tempText1"

    class TestNestedClass {
        fun testFun1() {
            println("TestFun1")
            println(tempText1)  //에러가 난다.(중첩클래스에서는 외부로 접근 못한다.)
        }
    }
}


//내부 클래스
class Test2 {
    val tempText2 = "tempText2"

    inner class Test2InnerClass {
        fun testFun2() {
            println("TestFun2")
            println(tempText2)  //출력이 된다.
        }
    }
}
==========================================================
//람다
fun main() {
    println(a())
    println(sumNumber(1,2))
}

fun sum(a:Int,b:Int) : Int {
    return a+b
}

val sumNumber = {a:Int, b:Int -> a+b}
val sumTypeNumber : (Int,Int) -> Int = {a,b -> a+b}
val sumTypeNumberNull : (Int, Int) -> Int? = {a,b->null}

fun a() : String{
    return "text"
}

fun b() = "text"

============================================================
fun main() {
    println(sumString("1","2"))
}

fun sumString(a:String, b:String) : String {
    return "string1 : $a string2 : $b;
}

val sumStringTwo = {a: String, b: String -> "string1 : $a string2: $b"}
val sumStringTypeTwo : (String, String) -> String = {a,b -> "string1:$a string2 : $b"}

=============================================================
//고차함수  f(f(x))
fun main() {
    sum(1,2, {a:Int, b:Int -> a+b})
    sum(1,2) {a:Int,b:Int->a+b}
    sum(1,2, ::testSum)  //함수를 넣는다라고 생각
}

fun sum(a : Int, b:Int, operation : (Int, Int) -> Int) {
    println("$a $b")  // 1 2
    println(operation(a,b)) // 3
}

//또 다른 방법
fun testSum(a:Int, b:Int) : Int {
    return a+b
}
=========================================================
fun main() {
    printTest("abc")
    highPrintTest(::printTest) //bbb
}
fun printTest(str:String) {
    println(str)
}
fun highPrintTest(operation : (String) -> Unit) { //Unit이 아무것도 리턴하지 않는다는의미다.
    operation("bbb")
}

fun test1() : Unit {
    println("abc")
}

fun test2() : Unit {
    println("abc2")
    return
}

fun test3() : Unit {
    println("abc3")
    return Unit
}

==========================================================
//제네릭
//컴파일시에 타입 체크를 할 수 있다.
//타입 캐스팅이 필요없다
fun main() {
    val box1 = Box1(10)
    println(box1.value) //10
    
    val box3 = Box3(10)
    val box4 = Box3("10")

    testFun1("abc")
    testFun2("a")
    testFun2(123)
}

fun testFun1(a:String) {
    println(a)
}

fun <T> testFun2(a:T) {
    println(a)
}

class Box1(test:Int) {
    var value = test
}

class Box3<T>(test:T) {
    var value = test
}
=============================================================
// object -> 싱글톤 패턴 (디자인패턴)
// 디자인패턴 -> 코드를 어떻게 짜는게 더 좋고, 어떤 방식으로 구성해야 유지보수가 쉬운가
//객체를 한개만 생성하도록 한다

fun main() {
    val test1 = TestClass()
    val test2 = TestClass()
    
    test1.count = 10
    println(test1.count) //10
    println(test2.count) //0
    
    test3.count = 10
    val test3 = testObject  
    val test4 = testObject
    println(test3.count) //10
    println(test4.count) //10
}

object testObject{
    init {
        println("testObject") //두번호출된다.
    }
    var count = 0
}

class TestClass {
    init{
        println("testClass")  //한번만 호출된다
    }
    var count = 0
}
=============================================================
//전역으로 사용이 가능하다.
fun main() {
    val test5 = TestObjectClass()
    val test6 = TestObjectClass()
    test5.plusBtn()
    println(TestObjectClass.number) //1
    
    test6.minusBtn()  //똑같은객체
    println(TestObjectClass.number) //0
}
class TestObjectClass {
    companion object {
        var number = 0
    }
    fun plusBtn() {
        number++
    }
    fun minusBtn() {
        number--
    }
}
===============================================================
//지연초기화
// lateinit / lazy

fun main() {
    var justString : String = "아무거나 스트링"
    
    println(justString)
    
    justString = "변경된 스트링"
    
    lateinit var lateString : String //위와 다르게 값을 초기화하지 않았다
    println(lateString) //값이 안들어갔기 때문에 에러가 난다.
    lateString = "변경된스트리밍"
    println(lateString)

    //그럼 왜 쓸까? -> 서버에서 받아온 데이터를 넣어두고 싶은데, 미리 변수를 선언해놓고 나중에 서버에서
    //값을 받아와서 넣어줄때 주로 사용한다.
    
    #)lazy
    val lazyString : String by lazy {
        "lazyTestString"
    }
    println(lazyString) //lazyTestString 이 잘나온다. lazyString을 사용하면 "lazyTestString"을 변수에넣어준다
    
    #)lazyString을 쓰지 않으면 값 할당("lazyTestString"이 할당 안된다) 
    val lazy123 : String by lazy {
        println("이 친구가 만들어질 때 프린트")
        "lazyTestString"
    }
    //lazyString  //안쓰는중

    //두 차이점은 지연초기화는 var을 쓰고, lazy는 val을 쓴다.
}
==============================================================
#) infix function

fun main() {
    println(sum(1,2))
    println(10 sum1 20) //30
    println("apple" sum1 "포도") //apple포도
    println("사과" sum2 "포도") //사과포도
    println(10 showList 20) //[10,11,12,...20]
}

//신버전
infix fun Int.sum1(num:Int) : Int = this+num
infix fun String.sum1(abc:String) : String = this+abc
infix fun String.sum2(abc:String) : String {
    return this+abc
}

infix fun Int.showList(num:Int) : List<Int> {
    val list = mutableListOf<Int>()
    for(i in this..num) {
        list.add(i)
    }
    println(this) //10
    return list
}
//구버전
fun sum(a:Int, b:Int) : Int {
    return a+b
}
==============================================================
//scope function
//let , with, run, apply, also

let -> non null일때 동작하고, null일때 동작하지 않도록
with -> 컨텍스트 내부에서 함수를 호출
run -> 객체 초기화와 return값 계산이 필요할 때 주로 사용
apply -> 값을 반환하지 않고, 객체 구성에 대해 주로 사용
also -> 객체에 대해 추가적인 작업


#)let
fun main() {
    val str : String? = "hi"
    
    val length = str?.let {
        println(it)//hi
        it.length
    }
    println(length) //2
    
    //null일때
    val str2 : String? = null
    val length2 = str2?.let {
        println(it) //null
        it.length //실행되지 않는다,
    }
    println(length2) //실행되지않는다.
}



#) with
val numbers = mutableListOf("a","b","c","d")
println(numbers.first()) //a
println(numbers.last())  //d

val firstAndLast = with(numbers) {
    "${first() ${last()}}" // a d
}
println(firstAndLast)


==============================================================
run -> 객체 초기화와 return값 계산이 필요할 때 주로 사용
apply -> 값을 반환하지 않고, 객체 구성에 대해 주로 사용
also -> 객체에 대해 추가적인 작업

fun main() {
    //run
    val service = multiPortService("www.naver.com",80)
    val result1 = service.query(service.perpareRequest() + " to port ${service.port}")
    
    println(result1) //결과 query 기본 요청 url www.naver.com to port 80

    val result2 = service.run {
        port=8080
        query(prepareRequest() + "to port $port")
    }
    println(result2) //결과 query 기본 요청 url www.naver.com to port 80
}

class multiPortService(var url : String, var port : Int) {
    fun prepareRequest() : String = "기본 요청 url $url"
    fun query(request : String) = "결과 query $request"
    
    
}

-----------------------
//apply

fun main() {
    val tester1 = Person("Tester1")
    println(tester1) //Person(name=Tester1, age=0, city=)
    
    tester1.age = 20
    tester1.city = "Seoul"
    
    println(tester1) //Person(name=Tester1, age=0, city=Seoul)
    
    val tester2 = Person("Tester2").apply {
        age = 21
        city = "Busan"
    }
    println(tester2) //Person(name=Tester1, age=0, city=Busan)
}

data class Person {
    var name : String,
    var age : Int = 0,
    var city : String = ""
}

class multiPortService(var url : String, var port : Int) {
    fun prepareRequest() : String  = "기본 요청 url $url"
    fun query(request : String) = "결과 query $request"
}

----------------------------
//also

fun main() {
    val numbers = mutableListOf(1,2,3,4)
    println("$numbers 여기에서 5를 추가합니다") //[1,2,3,4] 여기에서 5를 추가합니다
    numbers.add(5)
    println(numbers) // [1,2,3,4,5]
    
    val numbers2 = mutableListOf(1,2,3,4)
    numbers2.also {
        println("$numbers2 여기에서 5를 추가합니다") // [1,2,3,4] 여기에서 5를 추가합니다.
    }.add(5) 
    println(numbers2) // [1,2,3,4,5]
}


=============================================================
//enum class

fun main() {
    println(Direction.NORTH) //NORTH
    Direction.values().forEach {
        println(it) //NORTH ..
    }
    
    CustomerType.values().forEach {
        println(it)
    }
}

enum class Direction {
    NORTH, SOUTH, WEST, EAST
}

enum class CustomerType {
    A,B,C,D,VIP
}
==============================================================
fun main() {
    val direction = Direction.EAST
    when(direction) {
        Direction.NORTH -> {
            println("N")
        }
        Direction.SOUTH -> {
            println("S")
        }
        
    }
}

enum class Direction {
    NORTH, SOUTH, WEST, EAST
}

enum class CustomerType {
    A,B,C,D,VIP
}
==============================================================
fun main(){
    val color = Color.RED
    when(color) {
        Color.RED -> {
            println(Color.RED.rgb)
        }
        Color.GREEN -> {
            println(Color.GREEN.rgb)
        }
    }
    
    println(Device.DEVICEON.status) //ON
    Device.DEVICEON.status = "OFF"
    println(Device.DEVICEON.status) //OFF
}

enum class Color(val rgb : String) {
    RED("빨강"),
    GREEN("초록"),
    BLUE("파랑")
}

enum class Device(var status : String) {
    DEVICEON("ON")
    NETWORK("OFF")
    LOCATION("SEOUL")
}
==============================================================
// 여러 이메일이 담긴 리스트가 있어요!
// 저는 구글로 가입한 사람과 네이버로 가입한 사람의 숫자와
// 그 외의 기메일로 가입한 사람의 숫자를 보고 싶습니다.
// @와 .을 기준으로 어느 사이트에서 들어온 사람들인지 구분을 합니다.
// 아래와 같은 함수를 만들어보세요.

fun main(){

    val emailList1 = arrayListOf<String>("jay@naver.com",
        "john@naver.com",
        "emily@google.com",
        "ken@google.com",
        "minjun@kakao.com")
    val result1 = solution(emailList1)
    println(result1)
    // 결과값 = {naver=2, google=2, else=1}


    val emailList2 = arrayListOf<String>("Aiden@naver.com",
        "Andew@naver.com",
        "Adrian@daum.com",
        "Asher@google.com",
        "Austin@kakao.com",
        "Antonio@google.com")
    val result2 = solution(emailList2)
    println(result2)
    // 결과값 = {naver=2, google=2, else=2}


}

fun solution(emailList: ArrayList<String>) : Map<String, Int> { //Map형태로 리턴

    var naverCount = 0
    var googleCount = 0
    var elseCount = 0

    for(email in emailList){
        val domain = email.split("@")[1] //[naver.com] [naver.com]
        val emailItem = domain.split(".")[0] //위에 자른걸 . 기준으로 잘라서 첫번째꺼만
        //println(emailItem) //naver naver google...

        if(emailItem == "naver") {
            naverCount += 1 // naverCount++ , naverCount = naverCount + 1
        } else if(emailItem == "google"){
            googleCount += 1
        } else {
            elseCount += 1
        }

    }

    println(naverCount)
    println(googleCount)
    println(elseCount)

    val resultMap = mutableMapOf<String, Int>()

    resultMap["naver"] = naverCount
    resultMap["google"] = googleCount
    resultMap["elseCount"] = elseCount

    return resultMap

}
==============================================================
// 문자열의 숫자와 짝수(true)와 홀수(false)를 알려주는 solution을 만드세요

fun main(){

    val result1 = solution("abcd")
    println(result1)
    // [4, true]

    val result2 = solution("abcde")
    println(result2)
    // [5, false]
}


fun solution(str : String) : ArrayList<String> {

    // 길이 구하는 것 하나랑
    val length = str.length
    //println(length)

    // 구해진 길이가 홀수인지 짝수인지 알려주는 기능

    /*
    var isEven = true
    if(length % 2 == 0){
        //println("짝수")
        isEven = true
    } else {
        //println("홀수")
        isEven = false
    }
    */

    val isEven = length % 2 == 0

    val resultArray = arrayListOf<String>(length.toString(), isEven.toString())

    return resultArray

}


==============================================================
#)푸시알림
앱 푸쉬서비스는 인터넷 연결도 필요하기 때문에 인터넷 퍼미션도 추가해 준다.
<uses-permission android:name="andriod.permission.INTERNET"/>

백그라운드에서도 작동할 수 있도록 퍼미션 등록
<uses-permission android:name="android.permission.WAKE_LOCK"/>

핸드폰을 껏다가 킨 후에도 알림이 적용될 수 있도록하는 권한
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED


onMessageReceived() 메서드는 클라우드 서버에서 메시지를 전송하면 자동으로 호출되고
해당메서드 안에서 메시지를 처리한다.

#) Head Up Notification
Android O (API26)부터는 Notification을 하려면 Channel을 먼저 생성해주어야한다

//channel Id : 고유한 ID여야 하고 길면 잘릴 수 있다.
//Importance : 헤드업 알림이 되어야 한다면 IMPORTANCE_HIGH로 설정하고, 아니면 IMPOTANCE_DEFAULT로 설정한다.

//채널 생성함수
void createNotificationChannel(String channelId, String channelName, int importance) {
    if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.0) {
        Notification notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);
        notificationManager.createNotificationChannel(new NotificationChannel(channelId, channelName, importance))
    }
}

//채널 생성
createNotificationChannel(DEFAULT, "default channel", NotificationManager.IMPORTANCE_HIGH)


//Notification생성함수
void createNotification(String channelId, int id, String title, String text) {
    NotificationCompat.Builder builder = new NotificationCompat.Builder(this,channelId)
        .setpriority(NotificationCompat.PRIORITY_HIGH) //헤드업 알림을 위해서는 HIGH로 설정
        .setSmallIcon(R.drawable.ic_launcher_foreground) // 알림시 보여지는 아이콘
        .setContentTitle(title)
        .setContentText(text)
        .setTimeoutAfter(1000) // 지정한 시간 이후 알림이 사라진다.
        .setStyle(new NotificationCompat.BigTextStyle().bigText(text)) //text는 한줄이 넘어가면 짤린다. 모든 텍스트를 보여주기위해서는 BigText로
        .setDefaults(Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE); //알림시 효과음, 진동여부
        
    NotificationManager notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE)
    notificationManager.notify(id,builder.build())  //notify() : 생성한 notification을 등록한다. id가 같으면 1개의 notification만 보여짐
        
}

//해당 채널로 Notification 생성
createNotification(DEFAULT, 1, "제목", "본문")
=====================================================================================
public class MainActivity extends AppCompatActivity {
    private final String DEFAULT = "DEFAULT";
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        //Head Up Display를 위해 HIGH로 설정
        createNotificationChannel(DEFAULT, "default channel", NotificationManager.IMPORTANCE_HIGH);
        createNotification(DEFAULT,1,"title","text")
    }
    
    void createNotificationChannel(String channelId, String channelName, int importance) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationManager notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(new NotificationChannel(channelId, channelName, importance));
        }
    }
    
    void createNotification(String channelId, int id, String title, String text) {
         NotificationCompat.Builder builder = new NotificationCompat.Builder(this,channelId)
        .setpriority(NotificationCompat.PRIORITY_HIGH) //헤드업 알림을 위해서는 HIGH로 설정
        .setSmallIcon(R.drawable.ic_launcher_foreground) // 알림시 보여지는 아이콘
        .setContentTitle(title)
        .setContentText(text)
        .setTimeoutAfter(1000) // 지정한 시간 이후 알림이 사라진다.
        .setStyle(new NotificationCompat.BigTextStyle().bigText(text)) //text는 한줄이 넘어가면 짤린다. 모든 텍스트를 보여주기위해서는 BigText로
        .setDefaults(Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE); //알림시 효과음, 진동여부
        
    NotificationManager notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE)
    notificationManager.notify(id,builder.build())
    }
    
    void destroyNotification(int id) {
        NotificationManager notificationManager = (Notification)getSystemService(NOTIFICATION_SERVICE);
        notificationManager.cancel(id)
    }
}

==========================================================================
#) 클릭가능한 Notification을 만들면 된다.
우선 Intent를 생성하고, Notification 클릭시에 실행할 activity를 지정한다.

Intent intent = new Intent(this, MainActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVIY_SINGLE_TOP);

createNotification(DEFAULT, 1, "제목", "본문", intent)

void createNotification(String channelId, int id, String title, String text) {
         NotificationCompat.Builder builder = new NotificationCompat.Builder(this,channelId)
        .setpriority(NotificationCompat.PRIORITY_HIGH) //헤드업 알림을 위해서는 HIGH로 설정
        .setSmallIcon(R.drawable.ic_launcher_foreground) // 알림시 보여지는 아이콘
        .setContentTitle(title)
        .setContentText(text)
        .setContentIntent(pendingIntent) // PendingIntent를 지정하면 해당 Notification은 클릭이 가능해진다. 클릭시 실행될 PendingIntent지정
        .setTimeoutAfter(1000) // 지정한 시간 이후 알림이 사라진다.
        .setAutoCancel(true) //true이면 알림 클릭시 화면에서 사라진다. 만약 PendingIntent가 지정되지 않았다면 알림이 클릭되지 않으므로 setAutoCancel은 동작x
        .setStyle(new NotificationCompat.BigTextStyle().bigText(text)) //text는 한줄이 넘어가면 짤린다. 모든 텍스트를 보여주기위해서는 BigText로
        .setDefaults(Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE); //알림시 효과음, 진동여부
        
    NotificationManager notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE)
    notificationManager.notify(id,builder.build())
}

=========================================================================
#)AlarmManager와 TimePicker를 이용하여 원하는 시간 선택 -> 반복알림

----   ----  ----
 2   :  59    PM
----   ----  ----

등록(button)   해지(button)


우선 xml을 작성한다
#)activity.xml


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    
     <TimePicker
        android:id="@+id/tp_timepicker"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:timePickerMode="spinner"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
 
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        android:onClick="regist"  //온클릭이벤트
        android:text="등록"
        app:layout_constraintBaseline_toBaselineOf="@+id/button2"
        app:layout_constraintEnd_toStartOf="@+id/button2"
        app:layout_constraintHorizontal_bias="0.5"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tp_timepicker" />
 
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="28dp"
        android:onClick="unregist"   //온클릭이벤트
        android:text="해지"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.5"
        app:layout_constraintStart_toEndOf="@+id/button"
        app:layout_constraintTop_toBottomOf="@+id/tp_timepicker" />
 
</androidx.constraintlayout.widget.ConstraintLayout>


이제 정해진 시간에 실행되는 클래스를 BroadcastReceiver를 상속받을 것이다.
#)Alarm.java
public class Alarm extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "알람~!!", Toast.LENGTH_SHORT).show();
        Log.e("Alarm","알람입니다");
    }
    
}


#)MainActivity.java
public class MainActivity extends AppCompatActivity {
    private TimePicker timePicker;
    private AlarmManager alarmManager;
    private int hour, minute;
    
    @Override
    protected void onCreate(Bundle saveInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        timePicker=findViewById(R.id.tp_timepicker); //timePicker를 변수로 받아서 밑에서 쓰자
    }
    
    public void regist(View view) {
        Intent intent = new Intent(this,Alarm.class);
        PendingIntent pIntent = PendingIntent.getBroadcast(this,0,intent,0);
        
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            hour = timePicker.getHour();  //내가 선택한 시간
            minute = timePicker.getMinute();
        }
    
    Calendar calendar = Calendar.getInstance();
    calendar.set(Calendar.HOUR_OF_DAY, hour);
    calendar.set(Calendar.MINUTE,minute);
    calendar.set(Calendar.SECOND,0);
    calendar.set(Calendar.MILLISECOND,0);
    
    //지정한 시간에 매일 알림
    alarmManager.setRepeating(AlarmManager.RTC_WAKEUP,calendar.getTimeInMillis(), AlarmManager.INTERVAL_DAY, pIntent);
    }
    
    public void unregist(View view) {
        Intent intent = new Intent(this,Alarm.class);
        PendingIntent pIntent = PendingIntent.getBroadcast(this,0,intent,0);
        alarmManager.cancel(pIntent);
    }
}
=========================================================================
#) 진행과정(한번만 호출)
1. AlarmReceiver class 추가 (알람 이벤트를 받기 위한 broadcast receiver)
2. AlarmManager로 알람 추가 및 삭제 코드 구현

#)AndroidManifest.xml 에 아래 작성한 receiver추가
<receiver
    android:name=".service.AlarmReceiver"
    android:enabled="true">
    <intent-filter>
        <action android:name="android.intent.action.MAIN"></action>
    </intent-filter>
</receiver>

#) AlarmReceiver class 추가
AlarmManager로 알람을 추가했을 때 이벤트를 받기 위한 receiver를 추가한다.
예를들어 1분뒤로 알람을 추가하면 알람 receiver가 1분뒤 호출하게 된다.
이때 어떤 alarm인지는 "requestCode"로 구분되기 때문에 하나의 receiver로 모든 alarm을 분기해서 처리 할 수 있다.

public class AlarmReceiver extends BroadcastReceiver {
    private static final String TAG = "AlarmReceiver";
    @Override
    public void onReceive(Context context, Intent intent) {
        int reqCode = intent.getExtras().getInt("requestCode");
        Log.i(TAG,"onreceive: " + reqCode);
        if(reqCode == xxx) {
            //여기서 setAlarm
        }
    }
}

#) AlarmManager로 알람 추가 및 삭제코드 구현
AlarmManager로 알람을 추가할 때 x분뒤에 알람을 울리게 할지 아니면 3시 15분 등 특정시간에 울리게 할지 두가지 방법이있다.
RTC : 3시 15분 등 특정시간에 울리게
ELAPSED_REALTIME_WAKEUP : 지금 시간으로 부터 x분 뒤에 울리게

예를들어 현재 시간으로부터 10분뒤에 이벤트를 발생해라는 문구다
AlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 60 * 1000 * 10,alarmIntent);

public class AlarmController {
    private static final String TAG = "AlarmController"
    pricate Context context;
    private static AlarmController sInstance;
    private AlarmManager alarmMgr;
    
    private AlarmController(Context context) {
        this.context = context
        alarmMgr = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE;
    }
    
    public void setAlarm(int reqCode, long timeMill) {
        Log.i(TAG, "setAlarm req: " + reqCode + ", timeMill : " + timeMill);
        Intent intent = new Intent(context, AlarmReceiver.class);
        intent.putExtra(KEY_REQ_CODE, reqCode);
        PendingIntent alarmIntent = PendingIntent.getBroadcast(context, reqCode, intent,0);
        
        alarmMgr.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
        SystemClock.elapsedRealtime() + timeMill, alarmIntent);
    }
    
    public void cancelAlarm(int reqCode) {
        Log.i(TAG, "cancelAlarm req: " + reqCode);
        Intent intent = new Intent(context, AlarmReceiver.class);
        PendingIntent alarmIntent = PendingIntent.getBroadcast(context, reqCode,intent,0);
        
        if(alarmMgr != null) {
            alarmMgr.cancel(alarmIntent);
        }
    }
}
========================================================================
#) 현재 날짜 구하기
        Date currentTime = Calendar.getInstance().getTime();
        SimpleDateFormat weekdayFormat = new SimpleDateFormat("EE", Locale.getDefault());
        SimpleDateFormat dayFormat = new SimpleDateFormat("dd", Locale.getDefault());
        SimpleDateFormat monthFormat = new SimpleDateFormat("MM", Locale.getDefault());
        SimpleDateFormat yearFormat = new SimpleDateFormat("yyyy", Locale.getDefault());

        String weekDay = weekdayFormat.format(currentTime);
        String year = yearFormat.format(currentTime);
        String month = monthFormat.format(currentTime);
        String day = dayFormat.format(currentTime);

        Log.d("webnautes", year + "년 " + month + "월 " + day + "일 " + weekDay + "요일");

=========================================================================
#)현재날짜출력 방법
1. Date객체
2. Calendar Class
3. System Class

@Override
protected void onCreate(Bundle savedInstanceState)
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    //날짜 및 시간 형식 지정
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    //Date 객체 사용
    Date date = new Date();
    String time1 = simpleDateFormat.format(date);

    //Calendar 클래스의 getTime()함수 사용
    Calendar calendar = Calendar.getInstance();
    String time2 = simpleDateFormat.format(calendar.getTime());

    //System 클래스의 currentTimeMillis()함수 사용
    String time3 = simpleDateFormat.format(System.currentTimeMillis());

    Log.d("time", "time1 : " + time1);
    Log.d("time", "time2 : " + time2);
    Log.d("time", "time3 : " + time3);
}

2020-06-10 20:49:24.975 7352-7352/com.test.navermap D/time: time1 : 2020-06-10 20:49:24
2020-06-10 20:49:24.976 7352-7352/com.test.navermap D/time: time2 : 2020-06-10 20:49:24
2020-06-10 20:49:24.976 7352-7352/com.test.navermap D/time: time3 : 2020-06-10 20:49:24
========================================================================
#)특정날짜 알림 발송

#)AndroidManifest.xml

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.kwongyo.alarmtest" >
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.VIBRATE"/>
    <uses-permission android:name="android.permission.WAKE_LOCK"/>
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" >
        <activity android:name=".MainActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".Main2Activity"
            android:label="@string/title_activity_main2"
            android:theme="@style/AppTheme.NoActionBar" >
        </activity>
        <receiver android:name=".BroadcastD"></receiver> //여기가 핵심!!!!
    </application>
</manifest>

#)MainActivity.class

public class MainActivity extends AppCompatActivity {
    private static int ONE_MINUTE=5626;
    @Override
    protected void OnCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        new AlarmHATT(getApplicationContext()), Alarm();
    }
    
    public class AlarmHATT {
        private Context context;
        public AlarmHATT(Context context) {
            this.context = context;
        }
        public void Alarm() {
            AlarmManager am = (AlarmManager)getSystemService(Context.ALARM_SERVICE); //알람매니저 받기
            Intent intent = new Intent(MainActivity.this, BroadcastD.class); //알림이 왔을때, BroadcastD에게 방송을 해주기 위해서 명시적으로 알려줌
            
            PendingIntent sender = PendingIntent.getBroadcast(MainActivity.this,0,intent,0); 
            
            Calendar calendar = Calendar.getInstance();
            
            calendar.set(calendar.get(Calendar.YEAR),calendar.get(Calendar.MONTH), calendar.get(Calendar.DATE),23,12,0);
            
            //알람예약
            //RTC_WAKEUP : 대기 상태일 경우 단말기를 활성상태로 전환한후 작업을 수행
            am.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(),sender);
        }
        
    }
}


#)BroadcastD.class

public class BroadcastD extends BroadcastReceiver {
    String INTENT_ACTION = Intent.ACTION_BOOT_COMPLETED;
    
    @Override
    public void onReceive(Context context, Intent intent) { //알람시간이 되었을 때 onReceive를 호출한다.
        //노티 서비스 받고
        NotificationManager notificationmanager = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
        PendingIntent pendingIntent = PendingIntent.getActivity(context,0,new Intent(context, MainActivity.class), PendingIntent.UPDATE_CURRENT);
        Notification.Builder builder = new Notification.Builder(context);
        builder.setSmallIcon(R.drawble.on).setTicker("HETT").setWhen(System.currentTimeMillis())
               .setNumber(1).setContentTitle("푸시 제목").setContentText("푸시 내용")
               .setDefaults(Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE).setContentIntent(PendingIntent).setAutoCanel(true);
        notificationmanager.notify(1,builder.build());
        
    }
}
=========================================================================
#) PendingIntent는 생성자가 없고 아래 세개의 메소드들에 의해 객체가 생성된다.
.getActivity(Context, int, Intent, int)
.getBroadcast(Context, int, Intent, int)
.getService(Context, int, Intent, int)

그런데 이들 세 개의 메소드 중 어느 메소드에 의해서 생성된 PendingIntent 객체냐에 따라서
그 객체가 activity를 실행시킬지 서비스를 수행할지, 방송을 실행시킬지가 결정된다.

======================================================================
#)intent : 안드로이드 OS에게 저 이거 실행시켜주세여!! 시키는 것이다.
           이 부분에서 설정된 Activity로 이동할 수 있고, data도 보낼 수 있다.

#)intent가 단순하게 이거 실행시켜줘 !! 라고 한다면
pending intent는 메시지(예를들어 notification)를 통해 activity를 실행할수 있는데 
이때 사용하는 것이 PendingIntent이다.
pendingIntenteh Activity로 데이터를 전달할 수도 있다.

======================================================================
// Activity란?
안드로이드에서 액티비티는 앱의 화면을 말한다.
사용자가 직접 누를 수 있는 화면이다. 하지만, 개발자 관점에서는 activity는 두가지로 볼수있다.
기능을 담당하는 java파일과 ui를 담당하는 xml파일이 있다. 

** 하나의 java파일에서 하나의 xml이 연결되어 하나의 화면을 이룬다.

예를들어 xml파일속에 버튼이 있다면 그 버튼의 위치나 색깔 등 표면적인 것들은 xml파일안에서 수정한다.
하지만 클릭 했을 때의 동작은 그 xml파일에 해당하는 java파일에서 기능을 추가한다.

#) 새로운 화면을 만들고 시작화면으로 세팅하고 싶다면??
xml파일을 원하는 대로 만들었다면 java파일에서 연결을 시켜줘야한다. -> setContentView()를 사용

** 새로만든 파일을 AndroidManifest.xml에 명시해줘야한다. 
넣지않으면 안드로이드가 새로운 파일을 인식하지 못한다.

//새로만든 화면을 시작화면으로 바꾸고 싶다면??
//AndroidManifest.xml 안에 <intent-filter>가 있다. 이 안에 <category>를 사용해서 
//LAUNCHER 인지 DEFAULT인지 구별할 수 있게 되었다. 
//LAUNCHER로 구분되어 있는 클래스(java파일)가 시작화면을 뜻하고 DEFAULT는 그 외 입니다.
//시작화면을 제외한 나머지 부분에서는 <category>를 안해줘도 된다!!! 자동으로 DEFAULT로 명시

==========================================================================
#) 생명주기 메소드 호출 순서
- 시작할 때 : onCreate -> onStart -> onResume
- 화면 회전할 때 : onPause -> onStop -> onDestroy -> onCreate -> onStart -> onResume
- 홈 버튼 클릭 시 : onPause -> onStop
- 홈 이동 후 다시 돌아올 때 : onRestart -> onStart -> onResume
- 백 버튼 클릭하여 액티비티 종료 시 : onPause -> onStop -> onDestroy

===========================================================================
인텐트는 명시적 인텐트(Explicit Intent)와 암시적 인텐트(Implicit)가있다

1. 명시적 인텐트(MainActivity에서 button을 눌렀을 때 SecondActivity로 화면전환하는 코드다
/*MainActivity*/
 
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
 
 
public class MainActivity extends Activity implements View.OnClickListener{
Button button;
 @Override
 protected void onCreate(Bundle savedInstanceState) {
 super.onCreate(savedInstanceState);
 setContentView(R.layout.activity_main);
 button = (Button)findViewById(R.id.button);
 button.setOnClickListener(this);
 }
 
 @Override
 public void onClick(View v) {
 Intent intent = new Intent(getApplicationContext(),SecondActivity.class);
 startActivity(intent);
 }
}
=============================================================================
안드로이드 스튜디오를 개발하다보면 안드로이드에서 특정 권한을
획득해야 동작이 가능한 기능들이 있다.
안드로이드 마쉬멜로우 버전 이전에서는 그냥 바로 개발자가 코드상에 권한 허가를 넣어주면 됐지만
안드로이드 마쉬멜로우 버전 이후부터는 사용자가 직접 권한을 허락해야한다.(팝업창)

그럼 권한을 안드로이드 스튜디오에서 어떻게 얻을까?

#)AndroidManifest.xml

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.permission">
 
    <!-- 권한 추가 -->
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Permission">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
 
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

---------------------
#)권한얻기(MainActivity.java)
권한을 얻는 소스이다.
저장소 읽기, 쓰기 권한이 있는지 체크하여 없다면 사용자에게 권한을
허용할 지 물어봅니다.(팝업창) 권한이 없다면 앱을 종료시킨다.

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 권한ID를 가져옵니다
        int permission = ContextCompat.checkSelfPermission(this,
                Manifest.permission.WRITE_EXTERNAL_STORAGE);

        int permission2 = ContextCompat.checkSelfPermission(this,
                Manifest.permission.READ_EXTERNAL_STORAGE);

        // 권한이 열려있는지 확인(권한이 닫혀있으면 아래 코드를 실행해서 권한을 물어본다)
        if (permission == PackageManager.PERMISSION_DENIED || permission2 == PackageManager.PERMISSION_DENIED) {
            // 마쉬멜로우 이상버전부터 권한을 물어본다
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                // 권한 체크(READ_PHONE_STATE의 requestCode를 1000으로 세팅
                requestPermissions(
                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE},
                        1000);
            }
            return;
        }
    }

    // 권한 체크 이후로직
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grandResults) {
        // READ_PHONE_STATE의 권한 체크 결과를 불러온다
        if(requestCode == 1000) {
            boolean check_result = true;

            // 모든 퍼미션을 허용했는지 체크
            for (int result : grandResults) {
                if (result != PackageManager.PERMISSION_GRANTED) {
                    check_result = false;
                    break;
                }
            }

            // 권한 체크에 동의를 하지 않으면 안드로이드 종료
            if(check_result == true) {

            }
            else {
                finish();
            }
        }
    }
}

==================================================================
#) 권한이 얻기 위해서는 2가지 인데
- 권한창 띄우기
- 사용자가 직접 앱 설정에서 권한허용(이 방법은 사용자가 거의 안하므로 권한창 띄우는 걸로 추천)

1. manifest에 사용할 권한을 등록한다
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>

2. 메인코드
앱이 실행되면 권한창을 띄워주고, 권한을 허가하지 않으면 앱이 종료되는 코드

public class MainActivity extends AppCompatActivity {
    String[] permission_list = {
        Manifest.permission.WRITE_CONTACTS
    };
    
    @Override
    protected void onCreate(Bundel savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        checkPermission();
    }
    
    public void checkPermission() {
        //현재 안드로이드 버전이 6.0미만이면 메서드를 종료한다.
        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.M)
        return;
        
        for(String permission : permission_list) {
            //권한 허용여부를 확인한다.
            int chk = checkCallingOrSelfPermission(permission);
            //권한이 없다면
            if(chk == PackageManager.PERMISSION_DENIED) {
                //권한 허용 여부를 확인하는 창을 띄운다.
                requestPermission(permisson_list,0)
            }
        }
    }
    
}

@Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if(requestCode==0)
        {
            for(int i=0; i<grantResults.length; i++)
            {
                //허용됬다면
                if(grantResults[i]==PackageManager.PERMISSION_GRANTED){
                }
                else {
                    Toast.makeText(getApplicationContext(),"앱권한설정하세요",Toast.LENGTH_LONG).show();
                    finish();
                }
            }
        }
==============================================================
ContextCompat.checkSelfPermission() 메서드를 사용하여 앱에 이미 권한을 부여 받았는지 확인 가능
호출결과로는 PERMISSION_GRANTED 또는 PERMISSION_DENIED를 반환받게된다.

public static int checkSelfPermission(Context context, String permission)
-> return으로는 int형이고 -> PackageManager.PERMISSION_GRANTED, PackageManager.PERMISSION_DENIED 

#)사용예시 : ContextCompat.checkSelfPermission(this,Manifest.permission.ACCESS_FINE_LOCATION) //GPS와 네트워크를 이용하여 단말기 위치 식별

===============================================================
#) 앱에 필요한 권한을 요청하려는 경우 사용자가 처음 권한을 요청받은건지, 기존에 요청을 받았는데 거부를 한 것인지에 따라
요청방식을 달리 해야하고 요청화면도 달라지게 된다.

shouldShowRequestPermissionRationale() 메소드는 사용자가 이전에 권한 요청을 거부한 경우 true 값을 넘겨준다.
그 결과를 이용하여 앱을 사용하려면 권한이 필요함을 사용자에게 알려주는 안내만 추가하면된다.

함수) public static boolean shouldShowRequestPermissionRationale(Activity activity, String pemission)

예시) if(ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_FINE_LOCATION)) {
        //이전에 거부한 경우 해당
    }
    else { //처음요청하는 경우 그냥 권한요청하면됨}

===========================================================
#)권한요청
권한요청은 메소드를 호출하면서 필요한 권한을 적어주면 된다. 요청하려는 권한이 여러개이면 String 배열에
쭉 기입해 주면되고 너무 많으면 별도 배열 구성해서 추가가능

함수) static void requestPermissions(Activity activity, String[] permissions, int requestCode) //requestCode는 실행 후 전달받을 코드이다

#) 요청권한이 한개인 경우(배열에 한개)
static final int PERMISSIONS_REQUEST_READ_LOCATION=0x00000001;
ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, PERMISSIONS_REQUEST_READ_LOCATION);

#) 요청권한이 두개 이상인 경우
static final int PERMISSIONS_REQUEST_READ_LOCATION=0x0000001;
private String[] PERMISSIONS = {
    Manifest.permission.ACCESS_COARSE_LOCATION,
    Manifest.permission.ACCESS_FINE_LOCATION
};
ActivityCompat.requestPermissions(this,PERMISSIONS,PERMISSIONS_REQUEST_READ_LOCATION);

========================================================
#) 위에서 권한요청을 보내면 사용자가 권한요청 대화상자에 응답하면 시스템은 앱의 onRequestPermissionsResult() 메소드를 호출한다.
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    switch(requestCode) {
        case returnCode:
            if(grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                //권한이허가된경우
            }
            else {
                //권한이 거절된 경우
            }
            break;
    }
}
===========================================================












































